package main

import (
	"fmt"
	"os"
	"os/signal"

	"github.com/v1adis1av28/level2/tasks/task15/internal/reader"
)

//Необходимо реализовать собственный простейший Unix shell.
// Требования
// Ваш интерпретатор командной строки должен поддерживать:
// Встроенные команды:
// – cd <path> – смена текущей директории.
// – pwd – вывод текущей директории.
// – echo <args> – вывод аргументов.
// – kill <pid> – послать сигнал завершения процессу с заданным PID.
// – ps – вывести список запущенных процессов.
// Запуск внешних команд через exec (с помощью системных вызовов fork/exec либо стандартных функций os/exec).
// Конвейеры (pipelines): возможность объединять команды через |, чтобы вывод одной команды направлять на ввод следующей (как в обычном shell).
// Например: ps | grep myprocess | wc -l.
// Обработку завершения: при нажатии Ctrl+D (EOF) шелл должен завершаться; Ctrl+C — прерывание текущей запущенной команды, но без закрыватия самой shell.
// Дополнительно: реализовать парсинг && и || (условное выполнение команд),
// подстановку переменных окружения $VAR, поддержку редиректов >/< для вывода в файл и чтения из файла.
// Основной упор необходимо делать на реализацию базового функционала (exec, builtins, pipelines).
// Проверять надо как интерактивно, так и скриптом. Код должен работать без ситуаций гонки,
// корректно освобождать ресурсы.
// Совет: используйте пакеты os/exec, bufio (для ввода), strings.Fields (для разбиения командной
// строки на аргументы) и системные вызовы через syscall, если потребуется.

func main() {

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt)

	fmt.Println("Light version of unix shell!")

	if err := reader.ReadLines(); err != nil {
		fmt.Fprintf(os.Stderr, "Shell error: %v\n", err)
		os.Exit(1)
	}
}
