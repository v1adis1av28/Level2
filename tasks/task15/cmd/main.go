package main

import (
	"fmt"

	"github.com/v1adis1av28/level2/tasks/task15/internal/handler"
)

//Необходимо реализовать собственный простейший Unix shell.
// Требования
// Ваш интерпретатор командной строки должен поддерживать:
// Встроенные команды:
// – cd <path> – смена текущей директории.
// – pwd – вывод текущей директории.
// – echo <args> – вывод аргументов.
// – kill <pid> – послать сигнал завершения процессу с заданным PID.
// – ps – вывести список запущенных процессов.
// Запуск внешних команд через exec (с помощью системных вызовов fork/exec либо стандартных функций os/exec).
// Конвейеры (pipelines): возможность объединять команды через |, чтобы вывод одной команды направлять на ввод следующей (как в обычном shell).
// Например: ps | grep myprocess | wc -l.
// Обработку завершения: при нажатии Ctrl+D (EOF) шелл должен завершаться; Ctrl+C — прерывание текущей запущенной команды, но без закрыватия самой shell.
// Дополнительно: реализовать парсинг && и || (условное выполнение команд),
// подстановку переменных окружения $VAR, поддержку редиректов >/< для вывода в файл и чтения из файла.
// Основной упор необходимо делать на реализацию базового функционала (exec, builtins, pipelines).
// Проверять надо как интерактивно, так и скриптом. Код должен работать без ситуаций гонки,
// корректно освобождать ресурсы.
// Совет: используйте пакеты os/exec, bufio (для ввода), strings.Fields (для разбиения командной
// строки на аргументы) и системные вызовы через syscall, если потребуется.

//todo
// 1) написать ридер который будет читать строки от пользователя после чего передавать строку парсеру
// 2) написать парсер, который будет валидировать строку и проверять на наличие ошибок и разбирать команды в строке
// 3) написать command executor который будет выполнять команды полученные в строке

func main() {

	// ReaderErr := reader.ReadLines()
	// if errors.Is(ReaderErr, fmt.Errorf("Empty string")) {
	// 	fmt.Println(ReaderErr.Error())
	// }
	err := handler.HandleSingleCommand([]string{"cd", "pwd"})
	fmt.Println(err)
}
